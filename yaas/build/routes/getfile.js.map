{"version":3,"sources":["routes/getfile.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;gCAS6B,sBAAsB;;;;wBACtB,UAAU;;;;uBACV,SAAS;;;;oBACT,MAAM;;;;uBACN,UAAU;;;;sBACV,QAAQ;;;;kCACR,wBAAwB;;;;;AAErD,IAAI,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC;;AAEhC,SAAS,OAAO,CAAE,GAAG,EAAE,GAAG,EAAE;;;AAGxB,QAAI,GAAG,GAAG,cAAc,CAAC;;;AAGzB,QAAI,cAAc,GAAG,8BAAa,WAAW,EAAE,CAAC;;AAEhD,WAAO,0BAAY,UAAC,OAAO,EAAK;;;AAG5B,YAAI,MAAM,GAAG,cAAc,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;;;AAGlE,cAAM,CAAC,OAAO,CAAC,EAAC,YAAY,EAAE,GAAG,CAAC,MAAM,CAAC,QAAQ,EAAC,EAAE,UAAU,GAAG,EAAE,GAAG,EAAE;AACpE,gBAAG,CAAC,GAAG,EAAE;AACL,mBAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAC,KAAK,YAAU,GAAG,CAAC,MAAM,CAAC,QAAQ,gBAAa,EAAC,CAAC,CAAC;aAC3E,MACI;;AAED,oBAAI,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC;AAChC,oBAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;;;AAGtC,oBAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAG;AACxB,uBAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAC,KAAK,eAAa,OAAO,eAAY,EAAC,CAAC,CAAC;iBACjE,MAAM;;;AAGH,wBAAI,OAAO,GAAG,oBAAE,MAAM,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE,EAAE,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;;;AAG1E,wBAAI,iBAAiB,GAAG,oBAAE,KAAK,CAAC,OAAO,CAAC,CAAC;;;AAGzC,qCAAiB,CAAC,CAAC,GAAG,OAAO,CAAC;AAC9B,2BAAO,iBAAiB,CAAC,IAAI,CAAC;;;AAG9B,2BAAO,OAAO,CAAC,CAAC,CAAC;AACjB,2BAAO,OAAO,CAAC,IAAI,CAAC;AACpB,2BAAO,OAAO,CAAC,MAAM,CAAC;AACtB,2BAAO,OAAO,CAAC,QAAQ,CAAC;AACxB,kCAAc,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,4BAA0B,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAG,CAAC;;;;;;;AAO3F,wBAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;AACjD,kCAAc,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,qBAAmB,WAAW,CAAG,CAAC;;AAE9D,oDAAU,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,QAAQ,EACjC,OAAO,EAAE,kBAAK,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAChC,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;iBACxC;aACJ;SACJ,CAAC,CAAC;AACH,eAAO,CAAC,EAAG,CAAC,CAAC;KAChB,CAAC,CAAC;CAEN;;qBAEc,OAAO","file":"routes/getfile.js","sourcesContent":["/**\n * Created by r1cebank on 8/21/15.\n */\n\n/*!\n *  This is the getfile path, which handles retrieve the file and apply any\n *  transformation required by the client\n */\n\nimport AppSingleton     from '../util/appsingleton';\nimport Promise          from 'bluebird';\nimport Shortid          from 'shortid';\nimport Path             from 'path';\nimport UrlJoin          from 'url-join';\nimport _                from 'lodash';\nimport Transform        from '../transform/transform';\n//  Old require still using require\nvar hash = require('json-hash');\n\nfunction getfile (req, res) {\n\n    //  Log tag\n    let TAG = \"route:upload\";\n\n    //  Get shared instance from singleton\n    var sharedInstance = AppSingleton.getInstance();\n\n    return new Promise((resolve) => {\n\n        //  read the Nedb database stored on disk.\n        var bucket = sharedInstance.buckets.collection(req.params.bucket);\n\n        //  First the file needs to exist\n        bucket.findOne({originalname: req.params.filename}, function (err, doc) {\n            if(!doc) {\n                res.status(404).send({error: `file ${req.params.filename} not found.`});\n            }\n            else {\n                // Try to see if there is a get param for version\n                var version = doc.latestversion;\n                if(req.query.v) version = req.query.v;\n\n                //  Check if version exists\n                if(!doc.versions[version])  {\n                    res.status(404).send({error: `version ${version} not found`});\n                } else {\n\n                    //  Combining inputs\n                    var request = _.extend(req.params || {}, req.query || {}, req.body || {});\n\n                    //  This is used only for caching.\n                    var requestForHashing = _.clone(request);\n\n                    //  Again, delete the auth which is going to cause unexpected issue in hashing.\n                    requestForHashing.v = version;\n                    delete requestForHashing.auth;\n\n                    //  Needs to delete to avoid issues when deciding if processing is needed\n                    delete request.v;\n                    delete request.auth;\n                    delete request.bucket;\n                    delete request.filename;\n                    sharedInstance.L.verbose(TAG, `request for hashing: ${JSON.stringify(requestForHashing)}`);\n\n                    /*! Used for caching, since we need unique hash for each request and make sure the\n                     *  same request yields the same hash so we are ensure that our cache is always valid\n                     *  for a particular request. But! need a better caching system so that we won't use up\n                     *  memory/old cache is purged once TTL passed.\n                     */\n                    var requestHash = hash.digest(requestForHashing);\n                    sharedInstance.L.verbose(TAG, `request hash: ${requestHash}`);\n                    // Processing\n                    Transform.transform(res, doc.mimetype,\n                        request, Path.join(process.cwd(),\n                        doc.versions[version]), version);\n                }\n            }\n        });\n        resolve({ });\n    });\n\n}\n\nexport default getfile;"],"sourceRoot":"/source/"}